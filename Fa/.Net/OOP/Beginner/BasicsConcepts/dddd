🟢 اصول برنامه‌نویسی شی‌ءگرا (OOP Principles)
1️⃣ Encapsulation (کپسوله‌سازی)

🔹 تعریف کامل‌تر:
کپسوله‌سازی یعنی داده‌ها (Data) و رفتارها (Methods) در یک مکان واحد (کلاس) جمع شوند.
به این ترتیب:

داده‌ها از دسترسی مستقیم بیرونی محافظت می‌شوند (مثلاً کسی نتونه بدون محدودیت موجودی حساب بانکی رو تغییر بده).

دسترسی به داده‌ها فقط از طریق متدها یا Propertyهایی انجام می‌شود که ما اجازه می‌دهیم.
این موضوع یکی از مهم‌ترین اصول امنیت و کنترل داده در برنامه‌نویسی شی‌ءگراست.

📌 مزایا:

محافظت از داده‌ها

کاهش خطاهای برنامه‌نویسی

ساده‌تر شدن نگهداری کد

🔹 مثال در C#:

class BankAccount
{
    private double balance;  // فیلد خصوصی، مستقیم از بیرون قابل دسترسی نیست

    public void Deposit(double amount)
    {
        if (amount > 0)
            balance += amount; // فقط از طریق این متد می‌تونیم موجودی رو تغییر بدیم
    }

    public double GetBalance()
    {
        return balance; // دسترسی به موجودی فقط از طریق این متد
    }
}

// استفاده
BankAccount account = new BankAccount();
account.Deposit(5000);
Console.WriteLine($"موجودی: {account.GetBalance()} تومان");


📝 توضیح کد:

در اینجا فیلد balance به صورت private تعریف شده و هیچ کس از بیرون نمی‌تونه مستقیم بهش دسترسی پیدا کنه.

برای افزایش موجودی از متد Deposit استفاده می‌کنیم که یک شرط گذاشته (amount > 0) تا موجودی منفی و اشتباه ثبت نشه.

برای گرفتن موجودی، از متد GetBalance استفاده می‌کنیم.
👉 این دقیقا همون کپسوله‌سازی هست: دسترسی به داده‌ها فقط از راه‌هایی که ما تعریف می‌کنیم امکان‌پذیر است.

2️⃣ Inheritance (ارث‌بری)

🔹 تعریف کامل‌تر:
ارث‌بری یعنی یک کلاس جدید می‌تونه ویژگی‌ها (Properties) و رفتارها (Methods) یک کلاس دیگر رو به ارث ببره.
کلاس پایه یا والد (Base/Parent Class) یک سری قابلیت عمومی داره، و کلاس فرزند (Derived/Child Class) اون قابلیت‌ها رو به ارث می‌بره و می‌تونه ویژگی‌های جدید هم اضافه کنه.

📌 مزایا:

جلوگیری از تکرار کد (کدهای مشترک فقط یک بار در والد نوشته می‌شوند)

ساختار سلسله‌مراتبی بین کلاس‌ها

توسعه و نگهداری راحت‌تر

🔹 مثال در C#:

class Vehicle   // کلاس والد
{
    public string Brand { get; set; }

    public void Drive()
    {
        Console.WriteLine($"{Brand} در حال حرکت است...");
    }
}

class Car : Vehicle   // کلاس فرزند
{
    public int Doors { get; set; }
}

// استفاده
Car myCar = new Car { Brand = "BMW", Doors = 4 };
myCar.Drive();


📝 توضیح کد:

کلاس Vehicle یک Property به نام Brand و یک متد Drive داره.

کلاس Car از Vehicle ارث‌بری کرده و علاوه بر Brand و Drive، یک ویژگی جدید به نام Doors هم داره.

وقتی از کلاس Car شیء می‌سازیم، می‌تونیم هم از قابلیت‌های Vehicle و هم از ویژگی‌های جدید خود Car استفاده کنیم.

3️⃣ Polymorphism (چندریختی)

🔹 تعریف کامل‌تر:
Polymorphism یعنی یک نام مشترک (مثل یک متد) می‌تونه رفتارهای متفاوتی در کلاس‌های مختلف داشته باشه.
به زبان ساده: "یک دستور، چند رفتار".

📌 انواع چندریختی:

Overloading (بارگذاری متد): متدهایی با نام یکسان اما پارامترهای متفاوت.

Overriding (بازنویسی متد): متدی که در کلاس والد تعریف شده و کلاس فرزند اون رو تغییر می‌ده.

🔹 مثال در C#:

class Animal
{
    public virtual void Speak()
    {
        Console.WriteLine("حیوان صدا می‌دهد...");
    }
}

class Dog : Animal
{
    public override void Speak()
    {
        Console.WriteLine("سگ: واق واق!");
    }
}

class Cat : Animal
{
    public override void Speak()
    {
        Console.WriteLine("گربه: میاو!");
    }
}

// استفاده
Animal a1 = new Dog();
Animal a2 = new Cat();

a1.Speak();  // سگ: واق واق!
a2.Speak();  // گربه: میاو!


📝 توضیح کد:

در کلاس Animal متد Speak به صورت virtual تعریف شده (یعنی قابل بازنویسی در فرزندهاست).

کلاس‌های Dog و Cat این متد رو override کرده‌اند تا رفتار مخصوص خودشون رو داشته باشن.

وقتی با متغیر نوع Animal ولی مقدار Dog یا Cat فراخوانی می‌کنیم، متد مخصوص اون کلاس اجرا می‌شه.
👉 این همون چندریختیه: یک متد با نام یکسان (Speak) اما رفتارهای متفاوت.

4️⃣ Abstraction (انتزاع)

🔹 تعریف کامل‌تر:
Abstraction یعنی پنهان کردن جزئیات غیرضروری و فقط نشان دادن چیزهایی که مهم هستند.
به عنوان برنامه‌نویس، ما فقط با تعریف کلی کار می‌کنیم و جزئیات پیاده‌سازی به کلاس‌های فرزند سپرده می‌شه.

📌 راه‌های پیاده‌سازی در C#:

کلاس‌های Abstract

Interface

🔹 مثال در C#:

abstract class Shape
{
    public abstract double GetArea();  // متد انتزاعی (بدون پیاده‌سازی)
}

class Circle : Shape
{
    public double Radius { get; set; }
    public override double GetArea()
    {
        return Math.PI * Radius * Radius;
    }
}

class Rectangle : Shape
{
    public double Width { get; set; }
    public double Height { get; set; }
    public override double GetArea()
    {
        return Width * Height;
    }
}

// استفاده
Shape circle = new Circle { Radius = 5 };
Shape rectangle = new Rectangle { Width = 4, Height = 6 };

Console.WriteLine($"مساحت دایره: {circle.GetArea()}");
Console.WriteLine($"مساحت مستطیل: {rectangle.GetArea()}");


📝 توضیح کد:

کلاس Shape انتزاعی هست و متد GetArea رو تعریف کرده اما پیاده‌سازی نکرده.

هر کلاس فرزند (Circle و Rectangle) خودش متد GetArea رو به شکل خاص خودش پیاده‌سازی می‌کنه.

وقتی از circle.GetArea() استفاده می‌کنیم، فرمول دایره اجرا می‌شه و وقتی از rectangle.GetArea() استفاده کنیم، فرمول مستطیل.
👉 این باعث می‌شه فقط روی "چه چیزی" تمرکز کنیم (مساحت شکل) و نه "چطور محاسبه می‌شه".
