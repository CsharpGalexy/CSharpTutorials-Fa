# کلیدواژه `new` در C# و ASP.NET Core

------------------------------------------------------------------------

## مقدمه

در زبان برنامه‌نویسی C#، کلیدواژه‌ی `new` از آن دسته واژه‌هایی است که در
موقعیت‌های مختلف معانی متفاوتی دارد. این تنوع استفاده ممکن است برای
بسیاری از برنامه‌نویسان --- به‌ویژه در مراحل اولیه یادگیری --- گیج‌کننده
باشد. در این مقاله، به‌صورت کامل و با مثال‌های عملی، کاربردهای گوناگون
`new` را بررسی می‌کنیم و به تفاوت آن با مفاهیمی مانند `override`،
`virtual` و تخصیص حافظه در Heap و Stack نیز می‌پردازیم.

------------------------------------------------------------------------
## کاربردهای اصلی کلیدواژه `new`

کلیدواژه‌ی `new` در C# سه کاربرد اصلی دارد:

1.  **ایجاد شیء جدید از یک کلاس (Object Instantiation)**
2.  **پنهان‌سازی اعضای کلاس پایه (Member Hiding)**
3.  **استفاده در Generic Constraints برای محدود کردن نوع‌ها**

در ادامه هرکدام را با جزئیات و مثال بررسی می‌کنیم.

------------------------------------------------------------------------
### 1. ایجاد شیء جدید (Object Instantiation)

یکی از متداول‌ترین کاربردهای `new`، ساخت یک شیء جدید از کلاس است. در
واقع، هر زمان از `new` به همراه سازنده‌ی یک کلاس استفاده می‌کنیم، حافظه‌ی
لازم برای شیء در Heap تخصیص داده می‌شود.

مثال:

``` csharp
Person person = new Person();
person.Name = "Ali";
person.Age = 25;
```

در این مثال، با استفاده از `new Person()` یک نمونه‌ی جدید از کلاس
`Person` ساخته می‌شود و فضای لازم در Heap تخصیص می‌یابد.

------------------------------------------------------------------------

### 2. پنهان‌سازی اعضا (Member Hiding)

زمانی که در یک کلاس فرزند، عضوی با همان نام در کلاس پایه وجود دارد،
می‌توان با استفاده از کلیدواژه‌ی `new` عضو کلاس پایه را پنهان کرد.

مثال:

``` csharp
class BaseClass
{
    public void ShowMessage()
    {
        Console.WriteLine("Hello from Base Class");
    }
}

class DerivedClass : BaseClass
{
    public new void ShowMessage()
    {
        Console.WriteLine("Hello from Derived Class");
    }
}
```

در این مثال، متد `ShowMessage` در کلاس فرزند با استفاده از `new` متد
کلاس پایه را پنهان کرده است.\
اما توجه داشته باشید که در زمان فراخوانی از طریق نوع مرجع، نتیجه متفاوت
خواهد بود:

``` csharp
BaseClass obj = new DerivedClass();
obj.ShowMessage(); // خروجی: Hello from Base Class
```

چون در این حالت، متد پنهان‌شده (`new`) **چندریختی (Polymorphism)** را
فعال نمی‌کند.

------------------------------------------------------------------------

### 3. استفاده در Generic Constraints

در تعریف جنریک‌ها، از `new()` می‌توان برای اطمینان از وجود سازنده‌ی بدون
پارامتر در نوع داده‌شده استفاده کرد.

مثال:

``` csharp
public class Factory<T> where T : new()
{
    public T CreateInstance()
    {
        return new T();
    }
}
```

اینجا `where T : new()` تضمین می‌کند که نوع `T` حتماً دارای سازنده‌ی
پیش‌فرض است تا بتوانیم نمونه‌ای از آن بسازیم.

------------------------------------------------------------------------

## تفاوت `new` و `override`

کلیدواژه‌های `new` و `override` هر دو در کلاس‌های فرزند برای کنترل رفتار
اعضای ارث‌برده‌شده استفاده می‌شوند، اما عملکرد آن‌ها تفاوت اساسی دارد.

-   `new`: فقط **پنهان‌سازی (hiding)** انجام می‌دهد و چندریختی را فعال
    نمی‌کند.\
-   `override`: برای **بازنویسی (overriding)** متد مجازی (`virtual` یا
    `abstract`) استفاده می‌شود و چندریختی واقعی را فعال می‌کند.

### مثال مقایسه‌ای:

``` csharp
class Base
{
    public virtual void Display() => Console.WriteLine("Base");
}

class Derived1 : Base
{
    public new void Display() => Console.WriteLine("Derived - new");
}

class Derived2 : Base
{
    public override void Display() => Console.WriteLine("Derived - override");
}
```

اکنون دو رفتار متفاوت خواهیم داشت:

``` csharp
Base obj1 = new Derived1();
obj1.Display(); // Base (به خاطر new)

Base obj2 = new Derived2();
obj2.Display(); // Derived - override (به خاطر polymorphism)
```

------------------------------------------------------------------------
## محدودیت‌ها و نکات هشداردهنده

1.  استفاده‌ی بیش از حد از `new` برای پنهان‌سازی اعضا می‌تواند باعث ابهام
    در خوانایی کد شود.\
2.  بهتر است در طراحی شی‌گرا از `override` استفاده کنید مگر در شرایط خاصی
    که واقعاً نیاز به پنهان‌سازی دارید.\
3.  هنگام استفاده از `new` در متدهای جنریک، حتماً مطمئن شوید که نوع داده
    دارای سازنده‌ی بدون پارامتر است.

------------------------------------------------------------------------

### Memory allocation behavior

کلیدواژه‌ی `new` در زمان اجرا، بسته به نوع داده، حافظه را در ناحیه‌های
متفاوتی از RAM تخصیص می‌دهد:

-   برای **Reference Type**‌ها (مثل کلاس‌ها)، حافظه در **Heap** تخصیص
    می‌یابد.\
-   برای **Value Type**‌ها (مثل structها)، حافظه معمولاً در **Stack**
    تخصیص داده می‌شود.

این تفاوت بر سرعت اجرا و نحوه‌ی آزادسازی حافظه تأثیر دارد. به‌طور کلی،
تخصیص در Stack سریع‌تر است اما فضای محدودتری دارد، در حالی که Heap بزرگ‌تر
و انعطاف‌پذیرتر است ولی مدیریت حافظه در آن زمان‌برتر است.

------------------------------------------------------------------------
### جدول مقایسه `new` و `override`

  ویژگی                               new                override
  ----------------------------------- ------------------ ----------
  فعال‌سازی چندریختی                   ❌ ندارد           ✅ دارد
  نیاز به virtual/abstract            ❌ ندارد           ✅ دارد
  هشدار کامپایلر در نبود کلمه کلیدی   ✅ دارد (CS0108)   ❌ ندارد

------------------------------------------------------------------------

## نکات پیشرفته درباره‌ی `new`

-   در زمان استفاده از `new` در Generic Constraints، نمی‌توان سازنده‌ای با
    پارامترها را صدا زد --- فقط سازنده‌ی بدون پارامتر مجاز است.\
-   در کلاس‌های static، استفاده از `new` برای ساخت نمونه مجاز نیست چون
    این نوع کلاس‌ها قابل نمونه‌سازی نیستند.\
-   در Contextهای خاص مانند ASP.NET Core، از `new` برای ساخت دستی
    instance‌ها کمتر استفاده می‌شود چون معمولاً سیستم **Dependency
    Injection** این کار را انجام می‌دهد.

------------------------------------------------------------------------
## پیشنهاد پایانی برای توسعه‌دهندگان تازه‌کار

برای درک بهتر تفاوت‌های `new` و `override`، توصیه می‌شود چند مثال عملی
بنویسید و خروجی را در حالات مختلف مشاهده کنید.\
همچنین بررسی کنید چگونه `new` در کنار مفهوم **Polymorphism** و **Memory
Management** رفتار متفاوتی دارد.\
در پروژه‌های ASP.NET Core، سعی کنید به جای استفاده مستقیم از `new`، از
**Dependency Injection** برای مدیریت عمر اشیا استفاده کنید تا ساختار کد
تمیزتر و قابل تست‌تر باقی بماند.

------------------------------------------------------------------------

## منابع معتبر

-   مستندات رسمی Microsoft Docs\
-   کتاب **C# in Depth** نوشته‌ی Jon Skeet\
-   آموزش‌های رسمی .NET و ASP.NET Core
