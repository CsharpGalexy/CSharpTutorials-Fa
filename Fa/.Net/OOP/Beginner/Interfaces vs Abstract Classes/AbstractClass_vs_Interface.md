# Abstract Class vs Interface در C# --- مقایسه کامل

## فهرست مطالب

-   [تعریف کلی: چه زمانی از هر کدام استفاده
    کنیم؟](#تعریف-کلی-چه-زمانی-از-هر-کدام-استفاده-کنیم)\
-   [تفاوت‌های ساختاری و فنی](#تفاوت‌های-ساختاری-و-فنی)\
-   [ویژگی‌های جدید در نسخه‌های اخیر
    C#](#ویژگی‌های-جدید-در-نسخه‌های-اخیر-c)\
-   [نمونه کد: کلاس انتزاعی (Abstract
    Class)](#نمونه-کد-کلاس-انتزاعی-abstract-class)\
-   [نمونه کد: واسط (Interface)](#نمونه-کد-واسط-interface)\
-   [نمونه کد: ترکیب abstract class و interface با تمرکز بر
    Validation](#نمونه-کد-ترکیب-abstract-class-و-interface-با-تمرکز-بر-validation)\
-   [ترکیب abstract class و interface در طراحی
    واقعی](#ترکیب-abstract-class-و-interface-در-طراحی-واقعی)\
-   [چه زمانی از Abstract Class استفاده
    کنیم؟](#چه-زمانی-از-abstract-class-استفاده-کنیم)\
-   [چه زمانی از Interface استفاده
    کنیم؟](#چه-زمانی-از-interface-استفاده-کنیم)\
-   [محدودیت‌ها و چالش‌های هر دو
    رویکرد](#محدودیت‌ها-و-چالش‌های-هر-دو-رویکرد)\
-   [خلاصه و نتیجه‌گیری](#خلاصه-و-نتیجه-گیری)\
-   [منابع معتبر](#منابع-معتبر)

------------------------------------------------------------------------
## تعریف کلی: چه زمانی از هر کدام استفاده کنیم؟

در C#، کلاس‌های انتزاعی (abstract classes) و واسط‌ها (interfaces)
ابزارهایی برای **تعریف قراردادها** و **مدیریت طراحی شیءگرا** هستند.

-   **کلاس انتزاعی** زمانی استفاده می‌شود که بخواهیم یک **پایه مشترک** با
    داده‌ها یا منطق اشتراکی بسازیم.\
-   **واسط** زمانی کاربرد دارد که بخواهیم فقط یک **قابلیت مستقل** تعریف
    کنیم تا انواع مختلف (حتی نامرتبط) آن را پیاده‌سازی کنند.

📌 یک قانون ساده:\
- اگر رابطه *is-a* برقرار است («سگ یک حیوان است») → از **کلاس انتزاعی**
استفاده کنید.\
- اگر رابطه *can-do* برقرار است («پرنده می‌تواند پرواز کند») → از
**interface** استفاده کنید.

------------------------------------------------------------------------

## تفاوت‌های ساختاری و فنی

جدول زیر تفاوت‌ها را (C# 12 و .NET 8) نشان می‌دهد:

  -----------------------------------------------------------------------
  ویژگی          Abstract Class                    Interface
  -------------- --------------------------------- ----------------------
  شی‌سازی مستقیم  ❌                                ❌

  وراثت چندگانه  ❌ فقط یک کلاس پایه               ✅ چندین واسط

  فیلدها و خواص  ✅ فیلد و property نمونه مجاز     ❌ فقط ثابت‌ها و static

  سازنده         ✅ مجاز (معمولاً protected)       ❌ فقط static
                                                   constructor (از C# 11)

  متد            ✅ همیشه مجاز                     ✅ از C# 8 (default
  پیاده‌سازی‌شده                                     methods)

  سطح دسترسی     ✅ هر سطحی (public/private/...)   ✅ از C# 8 (در default
                                                   methods)

  حالت (State)   ✅ نگهداری حالت مجاز              ❌ حالت نمونه ندارد

  اعضای static   ✅ مجاز                           ✅ از C# 8 (static
                                                   abstract از C# 11)
  -----------------------------------------------------------------------

------------------------------------------------------------------------

## ویژگی‌های جدید در نسخه‌های اخیر C

از **C# 8** به بعد، واسط‌ها قدرتمندتر شدند:

### Default Interface Methods

مثال: متدی پیش‌فرض در واسط، بدون نیاز به override در همه کلاس‌ها.

``` csharp
public interface ILogger
{
    void Log(string message);

    // متد پیش‌فرض
    void LogError(string error) => Console.WriteLine($"Error: {error}");
}
```

### Static Abstract Members (از C# 11)

کلاس‌های پیاده‌کننده باید اعضای static مشخص‌شده در واسط را تعریف کنند.

``` csharp
public interface IParsable<T>
{
    static abstract T Parse(string input);
}

public class NumberParser : IParsable<int>
{
    public static int Parse(string input) => int.Parse(input);
}
```

این ویژگی‌ها واسط‌ها را به کلاس‌های انتزاعی نزدیک‌تر می‌کنند، اما همچنان
محدودیت‌هایی مانند **عدم نگهداری state** وجود دارد.

------------------------------------------------------------------------