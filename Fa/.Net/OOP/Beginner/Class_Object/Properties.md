# 📚 فهرست مطالب - انواع Properties در C#

---

## 🔗 لینک‌های سریع به بخش‌های اصلی

1. [🛠️ خصوصیات خود-پیاده‌سازی‌شده (Auto-Implemented)](#🛠️-خصوصیات-خود-پیاده‌سازی‌شده-auto-implemented-properties)
2. [🔧 خصوصیات کامل (Full Properties)](#🔧-خصوصیات-کامل-full-properties)
3. [🔒 خصوصیات فقط خواندنی (Read-Only)](#🔒-خصوصیات-فقط-خواندنی-read-only-properties)
4. [📝 خصوصیات فقط نوشتنی (Write-Only)](#📝-خصوصیات-فقط-نوشتنی-write-only-properties)
5. [🚪 خصوصیات فقط-ابتدایی (Init-Only)](#🚪-خصوصیات-فقط-ابتدایی-init-only-properties)
6. [➗ خصوصیات بدنه‌عبارت (Expression-bodied)](#➗-خصوصیات-بدنه‌عبارت-expression-bodied-properties)
7. [📊 خصوصیات محاسبه‌شده (Computed)](#📊-خصوصیات-محاسبه‌شده-computed-properties)
8. [🧱 فیلدهای پشتیبان (Backing Fields)](#🧱-فیلدهای-پشتیبان-backing-fields)
9. [📌 تفاوت‌ها و ارتباط‌های کلیدی](#📌-تفاوت‌ها-و-ارتباط‌های-کلیدی)
10. [🎯 جمع‌بندی نهایی](#🎯-جمع‌بندی-نهایی)

---


# انواع Properties در C#  
خصوصیات (Property) در C# به‌عنوان عناصر داده‌ای شناخته می‌شوند که مانند فیلدهای عمومی عمل می‌کنند اما پیاده‌سازی آن‌ها در قالب متدهای `get` و `set` است. همان‌طور که در مستندات مایکروسافت آمده است، «یک خصوصیت یک عضو است که سازوکاری انعطاف‌پذیر برای خواندن، نوشتن یا محاسبه‌ی مقدار یک فیلد داده فراهم می‌کند». به عبارت دیگر، به جای دسترسی مستقیم به فیلدها، از خصوصیات استفاده می‌شود تا امکان درج منطق اضافی (مانند اعتبارسنجی) فراهم گردد و در عین حال سینتکس دسترسی ساده به صورت فیلد حفظ شود. در ادامه انواع مختلف خصوصیات در C# بررسی می‌شوند:

---

## 🛠️ خصوصیات خود-پیاده‌سازی‌شده (Auto-Implemented Properties)  
**توضیح:** این نوع خصوصیت زمانی استفاده می‌شود که نیازی به منطق اضافی در `get` یا `set` نداریم. در این حالت، با نوشتن ساده‌ی `public string Name { get; set; }` کامپایلر به‌صورت خودکار یک فیلد خصوصی پنهان (backing field) می‌سازد که مقدار را نگه می‌دارد.  

**✅ موارد استفاده:**  
- مناسب برای نگهداری داده‌های ساده در کلاس‌ها یا ساختارها  
- جایی که تنها می‌خواهیم در دسترس‌پذیری عمومی و دستکاری بیرونی تفاوتی با فیلد داشته باشیم بدون اضافه کردن عملیات خاص  

**🌟 مزایا:**  
- سینتکس مختصر: سرعت نوشتن و خواندن کد را افزایش می‌دهد  
- ایمنی و کپسوله‌سازی: همچنان امکان افزودن اندکی ویژگی امنیتی (مانند `private set`) وجود دارد  
- مقدارسازی اولیه: می‌توان درجا مقدار اولیه داد (مثلاً `public string Name { get; set; } = ""`)  

**⚠️ معایب:**  
- عدم امکان منطق سفارشی: نمی‌توان مستقیماً درون `get` یا `set` اعتبارسنجی یا عملیات خاص نوشت  
- کمبود کنترل: تغییر رفتار این خصوصیت نیاز به تغییر شکل به خصوصیت کامل دارد  

```csharp
public class Person  
{  
    // Auto-implemented properties  
    public string FirstName { get; set; }  
    public string LastName  { get; set; }  
    public int    Age       { get; set; }  
}  

// استفاده  
var p = new Person { FirstName = "Ali", LastName = "Mousavi", Age = 30 };  
Console.WriteLine($"{p.FirstName} {p.LastName}, Age: {p.Age}");  
```

---

## 🔧 خصوصیات کامل (Full Properties)  
**توضیح:** در خصوصیات کامل، برنامه‌نویس خود یک فیلد خصوصی (backing field) تعریف می‌کند و بلوک‌های `get` و `set` را مستقیماً می‌نویسد. این امکان را می‌دهد تا منطق سفارشی، اعتبارسنجی، یا سایر عملیات هنگام خواندن/نوشتن مقدار انجام شود.  

**✅ موارد استفاده:**  
- زمانی که نیاز به کنترل یا منطق خاص هنگام دسترسی به داده‌ها باشد  
- مثلاً اعتبارسنجی ورودی، به‌روزرسانی فیلدهای وابسته، یا اجرای عملیات جانبی  

**🌟 مزایا:**  
- کنترل کامل: می‌توان هر جایی از پروپرتی منطق دلخواه اضافه کرد  
- پشتیبانی از فیلد پشتیبان مشخص: امکان تعریف فیلد خصوصی برای نگه‌داری واقعی داده فراهم است  

**⚠️ معایب:**  
- کد بیشتر: نیاز به نوشتن فیلد و بلوک‌های `get/set` دارد  
- پیچیدگی نگهداری: با اضافه شدن منطق درون پروپرتی، نگهداری و دیباگ سخت‌تر می‌شود  

```csharp
public class Account  
{  
    private decimal _balance;  // فیلد پشتیبان  

    public decimal Balance  
    {  
        get  
        {  
            return _balance;  
        }  
        set  
        {  
            if (value >= 0)   
                _balance = value;  
            else   
                throw new ArgumentException("Balance cannot be negative");  
        }  
    }  
}  

// استفاده  
var acc = new Account();  
acc.Balance = 100;    // set اجرا می‌شود  
Console.WriteLine(acc.Balance);  // get اجرا می‌شود  
```

---

## 🔒 خصوصیات فقط خواندنی (Read-Only Properties)  
**توضیح:** این خصوصیت‌ها تنها دارای بلوک `get` هستند و بلوک `set` ندارند. در نتیجه، بعد از مقداردهی اولیه (مثلاً در سازنده) دیگر نمی‌توان مقدار آن‌ها را تغییر داد.  

**✅ موارد استفاده:**  
- وقتی می‌خواهیم یک مقدار تنها یک‌بار (معمولاً در سازنده) تعیین شود  
- پس از آن توسط کد بیرون تغییر نیابد (مثل شناسه‌های ثابت)  

**🌟 مزایا:**  
- ایمن‌تر: پس از مقداردهی اولیه، امکان تغییر دادن وجود ندارد  
- سادگی: برای مواردی که نیاز به محاسبه‌ی مجدد یا منطق `set` نداریم، مناسب است  

**⚠️ معایب:**  
- غیرقابل تغییر: اگر بخواهیم در طول عمر شیء تغییرشان دهیم، باید از سازنده استفاده کنیم  
- عدم پشتیبانی از object initializer: بدون تعریف `init` یا `set` خصوصی، نمی‌توان با initializer مقداردهی کرد  

```csharp
public class Person  
{  
    public string FirstName { get; }   // فقط get  
    public string LastName  { get; }  

    public Person(string first, string last)  
    {  
        FirstName = first;  // مقداردهی در سازنده  
        LastName  = last;  
    }  
}  

var person = new Person("Sara", "Ahmadi");  
Console.WriteLine(person.FirstName); // ok: می‌توان خواند  
```

---

## 📝 خصوصیات فقط نوشتنی (Write-Only Properties)  
**توضیح:** این خصوصیت‌ها دارای بلوک `set` و بدون بلوک `get` هستند. یعنی می‌توان به آن‌ها مقدار داد ولی مقدارشان خوانده نمی‌شود.  

**✅ موارد استفاده:**  
- عملاً کاربرد محدودی دارند (مثل تنظیم کلمه‌ی عبور بدون امکان خواندن آن)  
- استفاده در الگوی تزریق وابستگی (setter injection)  

**🌟 مزایا:**  
- محرمانگی بیشتر: می‌توان اطلاعاتی را دریافت کرد بدون اینکه امکان خواندن آن وجود داشته باشد  

**⚠️ معایب:**  
- ضد الگوی طراحی: راهنمای طراحی مایکروسافت صراحتاً می‌گوید «خصوصیات فقط Set ارائه ندهید»  
- گیج‌کننده برای مصرف‌کننده: استفاده‌کننده از کلاس نمی‌تواند مقدار را بازیابی کند  

```csharp
public class SecureData  
{  
    private string _passwordHash;  

    // Write-only property  
    public string Password   
    {   
        set   
        {   
            _passwordHash = ComputeHash(value);  
        }   
    }  

    private string ComputeHash(string input)  
    {  
        return "HASHED_" + input;  
    }  
}  

var sd = new SecureData();  
sd.Password = "Secret123";  
```

---

## 🚪 خصوصیات فقط-ابتدایی (Init-Only Properties)  
**توضیح:** در C# 9 و بالاتر، کلیدواژه‌ی `init` معرفی شد تا امکان مقداردهی به خصوصیات تنها در زمان ساخت شیء فراهم گردد.  

**✅ موارد استفاده:**  
- برای کلاس‌هایی که می‌خواهیم پس از ساخت، ثابت باشند (Immutable)  
- در تعریف اشیاء بدون نوشتن کانستراکتر طولانی  

**🌟 مزایا:**  
- ایمیوتیبیلتی کنترل‌شده: امکان تغییر مقدار فقط در زمان ساخت را می‌دهد  
- سینتکس ساده‌تر: می‌توان بدون نوشتن کانستراکتر دستی از شیوه‌ی مقداردهی اولیه `{ }` استفاده کرد  

**⚠️ معایب:**  
- غیرقابل تغییر پس از ساخت: امکان تغییر آن خارج از زمان ساخت وجود ندارد  
- پشتیبانی نسخه: در C# 9 معرفی شده، در نسخه‌های قدیمی‌تر وجود ندارد  

```csharp
public class Person  
{  
    public string FirstName { get; init; }  
    public string LastName  { get; init; }  
    public int    Age       { get; init; }  
}  

// استفاده با object initializer (C# 9+)  
var person = new Person   
{   
    FirstName = "Reza",   
    LastName  = "Soleimani",   
    Age       = 28   
};  
```

---

## ➗ خصوصیات بدنه‌عبارت (Expression-bodied Properties)  
**توضیح:** اگر بلوک `get` یا `set` یک خصوصیت تنها شامل یک عبارت یک‌خطی باشد، می‌توان از صورت کوتاه‌تری به نام بدنه‌عبارت استفاده کرد.  

**✅ موارد استفاده:**  
- وقتی می‌خواهیم در یک عبارت ساده مقدار را محاسبه یا برگردانیم  
- برای خصوصیاتی که مقدارشان از یک محاسبه‌ی ساده حاصل می‌شود  

**🌟 مزایا:**  
- کد مختصر و خوانا: برای عملیات ساده مناسب است و کد را فشرده می‌کند  

**⚠️ معایب:**  
- محدودیت: فقط برای یک عبارت ساده به‌کار می‌رود  
- در صورت پیچیده شدن عملیات، باید از بلوک `get/set` معمولی استفاده کرد  

```csharp
public class Employee  
{  
    private int _birthYear;  

    // Expression-bodied get accessor:  
    public int Age => DateTime.Now.Year - _birthYear;  

    public Employee(int birthYear)  
    {  
        _birthYear = birthYear;  
    }  
}  

// استفاده  
var emp = new Employee(1990);  
Console.WriteLine(emp.Age);  
```

---

## 📊 خصوصیات محاسبه‌شده (Computed Properties)  
**توضیح:** یک خصوصیت محاسبه‌شده مقداری را بر اساس دیگر فیلدها یا خصوصیات شیء به‌صورت دینامیک می‌سازد.  

**✅ موارد استفاده:**  
- برای نمایش داده‌های مشتق‌شده از یک یا چند فیلد  
- مثال: ساخت نام کامل از نام و نام خانوادگی  

**🌟 مزایا:**  
- همیشه به‌روز: مقدار بر اساس وضعیت کنونی داده‌ها محاسبه می‌شود  
- کد شفاف: تعریف ساده و بدون نیاز به ذخیره اضافی  

**⚠️ معایب:**  
- هزینه محاسبه: در صورتی که محاسبه پیچیده باشد، ممکن است منابع بیشتری مصرف کند  

```csharp
public class Person  
{  
    public string FirstName { get; set; }  
    public string LastName  { get; set; }  

    // Computed property  
    public string FullName => FirstName + " " + LastName;  
}  

var person = new Person { FirstName = "Mina", LastName = "Karimi" };  
Console.WriteLine(person.FullName);  
```

---

## 🧱 فیلدهای پشتیبان (Backing Fields)  
**توضیح:** فیلد پشتیبان، یک فیلد خصوصی است که داده‌ی واقعی یک خصوصیت را نگه می‌دارد.  

**✅ موارد استفاده:**  
- فقط در خصوصیات کامل لازم است  
- در خصوصیات خود-پیاده، فیلد پشتیبان توسط کامپایلر به‌طور خودکار ایجاد می‌شود  

**🌟 مزایا:**  
- انعطاف‌پذیری: به ما امکان می‌دهد در `get` یا `set` کنترل و منطق خاص بنویسیم  
- پیاده‌سازی کش (Lazy) یا اعتبارسنجی: می‌توان مقدار را موقتی ذخیره کرد یا اعتبارسنجی انجام داد  

**⚠️ معایب:**  
- کد اضافی: یک فیلد جدید اضافه می‌کند که خود باید مدیریت شود  
- محدودیت دسترسی: باید خصوصی باشد تا فقط از طریق خصوصیت قابل دسترس باشد  

```csharp
public class Range  
{  
    private int _min;  // فیلد پشتیبان  

    public int Min  
    {  
        get { return _min; }  
        set   
        {  
            if (value <= _max)   
                _min = value;  
        }  
    }  

    private int _max;  // فیلد پشتیبان  

    public int Max  
    {  
        get { return _max; }  
        set   
        {  
            if (value >= _min)   
                _max = value;  
        }  
    }  
}  
```

---

## 📌 تفاوت‌ها و ارتباط‌های کلیدی

| ویژگی | خصوصیت خود-پیاده | خصوصیت کامل |
|--------|------------------|-------------|
| **فیلد پشتیبان** | توسط کامپایلر ایجاد می‌شود | توسط برنامه‌نویس تعریف می‌شود |
| **منطق سفارشی** | غیرممکن | امکان‌پذیر |
| **کد نوشته‌شده** | بسیار کوتاه | طولانی‌تر |

| ویژگی | فقط خواندنی | فقط ابتدایی |
|--------|------------|------------|
| **مقداردهی** | فقط در سازنده | در سازنده یا Object Initializer |
| **تغییر پس از ساخت** | غیرممکن | غیرممکن |
| **انعطاف‌پذیری** | کمتر | بیشتر |

> 💡 **نکته طلایی:**  
> - از خصوصیت‌های فقط نوشتنی به ندرت استفاده کنید (معمولاً یک متد مناسب‌تر است)  
> - برای اشیاء Immutable از `init` در C# 9.0+ استفاده کنید  
> - خصوصیت‌های محاسبه‌شده را برای عملیات سبک طراحی کنید (برای عملیات سنگین از کش استفاده کنید)

---

## 🎯 جمع‌بندی نهایی
هر نوع خصوصیت بر اساس نیاز طراحی انتخاب می‌شود:
- **برای سادگی و سرعت**: خصوصیت خود-پیاده  
- **برای کنترل کامل**: خصوصیت کامل  
- **برای ایمنی داده**: خصوصیت‌های فقط خواندنی یا init-only  
- **برای خوانایی کد**: خصوصیت‌های Expression-bodied  
- **برای داده‌های مشتق‌شده**: خصوصیت‌های محاسبه‌شده  

انتخاب هوشمندانه‌ی نوع خصوصیت، کدی ایمن، خوانا و قابل نگهداری ایجاد می‌کند که اصول SOLID و کپسوله‌سازی را رعایت می‌کند.